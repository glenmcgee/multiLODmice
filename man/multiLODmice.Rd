% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiLODmice.R
\name{multiLODmice}
\alias{multiLODmice}
\title{Main function for mice with multiply left censored data.}
\usage{
multiLODmice(data, data.lod, mi.m, maxit = 10, return.midsObject = FALSE)
}
\arguments{
\item{data}{dataset including some missing or censored values}

\item{data.lod}{dataset containing columns corresponding to LOD values (left censors) and NA elsewhere (for non-censored observations or truly missing values). Column names must match columns from \code{data} with censored values.}

\item{mi.m}{Number of imputed datasets}

\item{y}{Vector to be imputed}

\item{ry}{Logical vector of length \code{length(y)} indicating the the subset
\code{y[ry]} of elements in y to which the imputation model is fitted.
The \code{ry} generally distinguishes the observed (\code{TRUE}) and
missing values (\code{FALSE}) in y.}

\item{x}{Numeric design matrix with \code{length(y)} rows with predictors
for \code{y}. Matrix \code{x} may have no missing values.}

\item{lod.j}{Vector of varying LODs (left censoring values). -Inf for non censored values.}

\item{wy}{Logical vector of length \code{length(y)}. A \code{TRUE} value
indicates locations in \code{y} for which imputations are created.}

\item{...}{Other named arguments.}
}
\description{
Calls mice with custom method for multiply left censored data. Based on \code{Lapidus et al.} for imputing left-censored data with mice; extended to varying LODs. Modified version of MImpute_lcens function from doMIsaul package.
}
\examples{
set.seed(123)
require(crch)
require(censReg)
require(mvtnorm)

## generate complete data
n <- 5000
dat <- gendat_multiLOD(n)
X <- dat$X
df <- dat$df
LODs <- dat$LODs

## impute data
kk <- 20
df_imp <- multiLODmice(data = df, data.lod = LODs,mi.m = kk)

## check that imputed values are correctly below the LOD
sum(sapply(df_imp,function(dat) sum(dat$X1[is.na(df$X1) & seq(1,n)<(n/2)]> (-2))))==0 ## first LOD for X1
sum(sapply(df_imp,function(dat) sum(dat$X1[is.na(df$X1) & seq(1,n)>(n/2)]> (-1))))==0 ## second LOD for X1
sum(sapply(df_imp,function(dat) sum(dat$X2[is.na(df$X2) & seq(1,n)<(n/2)]> (-1))))==0 ## first LOD for X2
sum(sapply(df_imp,function(dat) sum(dat$X2[is.na(df$X2) & seq(1,n)>(n/2)]> (-2))))==0 ## second LOD for X2

## compare imputations to true values
mean_imp1 <- apply(sapply(df_imp,function(dat) dat$X1[is.na(df$X1)]),1,mean)
mean_imp2 <- apply(sapply(df_imp,function(dat) dat$X2[is.na(df$X2)]),1,mean)

## check accuracy
summary(lm(X[is.na(df$X1),1]~mean_imp1))
summary(lm(X[is.na(df$X2),2]~mean_imp2))


}
